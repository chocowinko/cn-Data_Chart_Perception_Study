<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Global Migration Flow Tracing</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        background: transparent;
        overflow: hidden;
      }

      .container {
        max-width: 100%;
        height: auto;
        margin: 0px auto;
        background: transparent;
        padding: 0;
        border-radius: 0;
        box-shadow: none;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
      }

      h1 {
        display: none;
      }

      .info-panel {
        background: #f8f9fa;
        border-radius: 8px;
        margin-bottom: 20px;
        border-left: 4px solid #3498db;
      }

      .legend {
        display: flex;
        flex-wrap: wrap;
        justify-content: flex-start;
        width: 100%;
        gap: 20px;
        margin: 15px 0;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 15px;
      }

      .legend-color {
        width: 25px;
        height: 6px;
        border-radius: 2px;
      }

      #chart-container {
        position: relative;
        width: 100%;
        flex: 1;
        margin: 0;
        border: none;
        overflow: hidden;
        background: transparent;
      }

      #loading {
        text-align: center;
        margin-top: 20px;
        font-size: 16px;
        color: #555;
      }

      svg {
        position: relative;
        z-index: 1;
        background: transparent;
      }

      .link {
        fill: none;
        stroke-opacity: 0.7;
      }

      .node {
        stroke: #fff;
        stroke-width: 3px;
      }

      .node-label {
        font-size: 13px;
        font-weight: 600;
        text-anchor: middle;
        pointer-events: none;
        fill: #333;
      }

      .route-path {
        fill: none;
        stroke-linecap: round;
        stroke-opacity: 0.8;
      }

      .world-map {
        fill: #e8e8e8;
        stroke: #d0d0d0;
        stroke-width: 0.5;
        opacity: 0.6;
      }

      .label-bg {
        fill: rgba(255, 255, 255, 0.9);
        stroke: #ddd;
        stroke-width: 1;
        rx: 4;
        ry: 4;
        display: none;
      }

      .trajectory-legend {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 10px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        font-size: 9px;
        z-index: 10;
      }

      .trajectory-legend h4 {
        margin: 0 0 7px 0;
        color: #333;
        font-size: 11px;
        font-weight: 600;
      }

      .legend-item-trajectory {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
        gap: 7px;
      }

      .legend-line {
        width: 20px;
        height: 2px;
        border-radius: 1px;
      }

      .legend-text {
        color: #555;
        font-weight: 500;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <h1>Global Migration Flow Tracing</h1>

      <div class="legend" id="legend"></div>

      <div id="chart-container">
        <div id="loading"><span>加载数据中...</span></div>
        <svg id="map" width="100%" height="600"></svg>

        <!-- 轨迹图例 -->
        <div class="trajectory-legend">
          <h4>路线图例</h4>
          <div class="legend-item-trajectory">
            <div class="legend-line" style="background-color: #ff6b6b"></div>
            <span class="legend-text">路线1：东向北美</span>
          </div>
          <div class="legend-item-trajectory">
            <div class="legend-line" style="background-color: #4ecdc4"></div>
            <span class="legend-text">路线2：西向欧洲</span>
          </div>
          <div class="legend-item-trajectory">
            <div class="legend-line" style="background-color: #45b7d1"></div>
            <span class="legend-text">路线3：全球连接路线</span>
          </div>
        </div>
      </div>
    </div>

    <script>
      /* ---------- 全局变量与常量 ---------- */
      let dataLoaded = null
      let links = []
      let thicknessScale

      const regions = [
        'EUROPE',
        'NORTHERN AMERICA',
        'Central and Southern Asia',
        'Latin America and the Caribbean',
        'Oceania (excluding Australia and New Zealand)',
        'Sub-Saharan Africa',
        'Eastern and South-Eastern Asia',
      ]
      const regionNames = {
        EUROPE: '欧洲',
        'NORTHERN AMERICA': '北美洲',
        'Central and Southern Asia': '中南亚',
        'Latin America and the Caribbean': '拉丁美洲',
        'Oceania (excluding Australia and New Zealand)': '大洋洲',
        'Sub-Saharan Africa': '撒哈拉以南非洲',
        'Eastern and South-Eastern Asia': '东亚和东南亚',
      }

      const regionColors = {
        EUROPE: '#8dd3c7',
        'NORTHERN AMERICA': '#E2D874',
        'Central and Southern Asia': '#bebada',
        'Latin America and the Caribbean': '#fdb462',
        'Oceania (excluding Australia and New Zealand)': '#b3de69',
        'Sub-Saharan Africa': '#f49fc7',
        'Eastern and South-Eastern Asia': '#bc80bd',
      }

      // 动态获取SVG宽度并设置投影
      let svgWidth,
        svgHeight = 600
      let projection, pos

      function initializeProjection() {
        const svg = document.getElementById('map')
        svgWidth = svg.getBoundingClientRect().width

        projection = d3
          .geoMercator()
          .center([30, 15])
          .scale(svgWidth * 0.18)
          .translate([svgWidth / 2, svgHeight / 2])

        pos = {
          EUROPE: projection([15, 50]),
          'NORTHERN AMERICA': projection([-100, 45]),
          'Central and Southern Asia': projection([70, 30]),
          'Latin America and the Caribbean': projection([-70, -20]),
          'Oceania (excluding Australia and New Zealand)': projection([140, -20]),
          'Sub-Saharan Africa': projection([20, -10]),
          'Eastern and South-Eastern Asia': projection([110, 20]),
        }
      }

      /* ---------- 数据处理与初始化 ---------- */
      const svg = d3.select('#map')
      const mapGroup = svg.append('g').attr('id', 'map-group')
      const linkGroup = svg.append('g').attr('id', 'link-group')
      const nodeGroup = svg.append('g').attr('id', 'node-group')
      const labelGroup = svg.append('g').attr('id', 'label-group')
      const loadingDiv = document.getElementById('loading')

      function initialize() {
        initializeProjection()
        drawWorldMap()
        createLegend()
        d3.csv('imbig_data.csv')
          .then((data) => {
            loadingDiv.style.display = 'none'
            processData(data)
            drawAllRoutes()
          })
          .catch((error) => {
            console.error('Error loading data:', error)
            loadingDiv.textContent = '数据加载失败，请检查文件。'
            loadingDiv.style.color = 'red'
          })
      }

      function drawWorldMap() {
        const path = d3.geoPath().projection(projection)
        d3.json('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json')
          .then((worldData) => {
            mapGroup
              .selectAll('path')
              .data(topojson.feature(worldData, worldData.objects.countries).features)
              .enter()
              .append('path')
              .attr('d', path)
              .attr('class', 'world-map')
          })
          .catch((error) => {
            console.error('Error loading map data:', error)
          })
      }

      function createLegend() {
        const legendContainer = document.getElementById('legend')
        regions.forEach((region) => {
          const legendItem = document.createElement('div')
          legendItem.className = 'legend-item'

          const colorBox = document.createElement('div')
          colorBox.className = 'legend-color'
          colorBox.style.backgroundColor = regionColors[region]

          const label = document.createElement('span')
          label.textContent = regionNames[region]

          legendItem.appendChild(colorBox)
          legendItem.appendChild(label)
          legendContainer.appendChild(legendItem)
        })
      }

      function processData(data) {
        dataLoaded = data
        links = []
        data.forEach((row) => {
          const src = row['Origin Region']
          regions.forEach((tgt) => {
            const value = +row[tgt]
            if (value > 0 && src !== tgt) {
              links.push({
                source: src,
                target: tgt,
                value: value,
                color: regionColors[tgt],
              })
            }
          })
        })

        const maxValue = d3.max(links, (d) => d.value)
        thicknessScale = d3.scalePow().exponent(0.5).domain([0, maxValue]).range([1, 15])
      }

      function drawAllRoutes() {
        // 绘制节点和标签
        drawStaticElements()

        // 先绘制所有路线作为浅灰色背景
        drawBackgroundRoutes()

        // 不自动开始动画，等待用户点击
        // startTracingAnimation()
      }

      // 暴露给父窗口调用的函数
      window.playHighlightAnimation = function () {
        // 清除之前的轨迹路径
        linkGroup.selectAll('.trajectory-path').remove()

        // 重置所有节点
        nodeGroup
          .selectAll('.node')
          .transition()
          .duration(300)
          .attr('r', 10)
          .attr('stroke-width', 3)

        // 延迟后开始动画
        setTimeout(() => {
          startTracingAnimation()
        }, 400)
      }

      function drawBackgroundRoutes() {
        // 绘制所有路线作为浅灰色背景
        links.forEach((link) => {
          const s = { x: pos[link.source][0], y: pos[link.source][1] }
          const t = { x: pos[link.target][0], y: pos[link.target][1] }
          const dx = t.x - s.x
          const dy = t.y - s.y
          const dr = Math.sqrt(dx * dx + dy * dy)

          const pathData = `M${s.x},${s.y}A${dr},${dr} 0 0,1 ${t.x},${t.y}`
          const strokeWidth = thicknessScale(link.value)

          // 背景路线（浅灰色）
          linkGroup
            .append('path')
            .attr('class', 'background-path')
            .attr('d', pathData)
            .attr('stroke', '#e0e0e0')
            .attr('stroke-width', strokeWidth)
            .attr('stroke-opacity', 0.3)
            .attr('fill', 'none')
        })
      }

      function startTracingAnimation() {
        // 定义三条轨迹
        const trajectories = [
          {
            name: '路线1：东向北美',
            color: '#FF6B6B', // 红色
            segments: [
              {
                from: 'Central and Southern Asia',
                to: 'Eastern and South-Eastern Asia',
                flow: 2745896,
              },
              {
                from: 'Eastern and South-Eastern Asia',
                to: 'NORTHERN AMERICA',
                flow: 347206,
              },
            ],
          },
          {
            name: '路线2：西向欧洲',
            color: '#4ECDC4', // 青色
            segments: [
              {
                from: 'Central and Southern Asia',
                to: 'EUROPE',
                flow: 2247003,
              },
            ],
          },
          {
            name: '路线3：全球连接路线',
            color: '#45B7D1', // 蓝色
            segments: [
              {
                from: 'Central and Southern Asia',
                to: 'EUROPE',
                flow: 2247003,
              },
              {
                from: 'EUROPE',
                to: 'NORTHERN AMERICA',
                flow: 6567672,
              },
              {
                from: 'NORTHERN AMERICA',
                to: 'Latin America and the Caribbean',
                flow: 27391708,
              },
            ],
          },
        ]

        const animationSpeed = 130 // 像素/秒 (提高速度)

        // 同时开始所有轨迹动画
        trajectories.forEach((trajectory, index) => {
          animateTrajectory(trajectory, index)
        })
      }

      function animateTrajectory(trajectory, trajectoryIndex) {
        let currentSegmentIndex = 0

        function animateNextSegment() {
          if (currentSegmentIndex >= trajectory.segments.length) return

          const segment = trajectory.segments[currentSegmentIndex]
          const fromPos = pos[segment.from]
          const toPos = pos[segment.to]

          // 计算路径，添加偏移避免重合
          const dx = toPos[0] - fromPos[0]
          const dy = toPos[1] - fromPos[1]
          const distance = Math.sqrt(dx * dx + dy * dy)

          // 为不同轨迹添加偏移，避免重合
          let offset = 0
          const segmentKey = `${segment.from}-${segment.to}`

          // 检查是否是重合的中亚到欧洲路径
          if (segmentKey === 'Central and Southern Asia-EUROPE') {
            if (trajectory.name === '路线2：西向欧洲') {
              offset = 20 // 向上偏移
            } else if (trajectory.name === '路线3：全球连接路线') {
              offset = -20 // 向下偏移
            }
          }

          const dr = distance + Math.abs(offset)
          const sweep = offset > 0 ? 0 : 1 // 控制弧形方向

          const pathData = `M${fromPos[0]},${fromPos[1]}A${dr},${dr} 0 0,${sweep} ${toPos[0]},${toPos[1]}`
          const strokeWidth = thicknessScale(segment.flow)

          // 创建路径
          const path = linkGroup
            .append('path')
            .attr('class', 'trajectory-path')
            .attr('d', pathData)
            .attr('stroke', trajectory.color)
            .attr('stroke-width', strokeWidth)
            .attr('stroke-opacity', 0.9)
            .attr('fill', 'none')
            .attr('stroke-linecap', 'round')

          // 获取路径总长度
          const totalLength = path.node().getTotalLength()

          // 设置初始状态（不可见）
          path
            .attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)

          // 计算动画持续时间（基于恒定速度）
          const duration = (totalLength / 130) * 1000 // 130像素/秒

          console.log(
            `${trajectory.name} - 段${currentSegmentIndex + 1}: ${segment.from} → ${segment.to}, 距离: ${totalLength.toFixed(0)}px, 持续时间: ${(duration / 1000).toFixed(1)}s`,
          )

          // 执行绘制动画
          path
            .transition()
            .duration(duration)
            .ease(d3.easeLinear)
            .attr('stroke-dashoffset', 0)
            .on('end', function () {
              currentSegmentIndex++

              // 如果还有下一段，在中转点停顿0.5秒后继续
              if (currentSegmentIndex < trajectory.segments.length) {
                // 高亮中转节点
                nodeGroup
                  .selectAll('.node')
                  .filter((d) => d.id === segment.to)
                  .transition()
                  .duration(200)
                  .attr('r', 15)
                  .attr('stroke-width', 5)
                  .transition()
                  .delay(300)
                  .duration(200)
                  .attr('r', 10)
                  .attr('stroke-width', 3)

                setTimeout(() => {
                  animateNextSegment()
                }, 500) // 0.5秒停顿
              }
            })
        }

        // 开始第一段动画
        animateNextSegment()
      }

      function drawStaticElements() {
        const nodes = regions.map((r) => ({ id: r, x: pos[r][0], y: pos[r][1] }))

        // 绘制节点
        nodeGroup
          .selectAll('.node')
          .data(nodes)
          .enter()
          .append('circle')
          .attr('class', 'node')
          .attr('r', 10)
          .attr('cx', (d) => d.x)
          .attr('cy', (d) => d.y)
          .attr('fill', (d) => regionColors[d.id])
          .attr('stroke', '#fff')
          .attr('stroke-width', 3)

        // 标签背景
        labelGroup
          .selectAll('.label-bg')
          .data(nodes)
          .enter()
          .append('rect')
          .attr('class', 'label-bg')
          .attr('x', (d) => d.x - 55)
          .attr('y', (d) => d.y - 26)
          .attr('width', 110)
          .attr('height', 20)

        // 标签文字
        labelGroup
          .selectAll('.node-label')
          .data(nodes)
          .enter()
          .append('text')
          .attr('class', 'node-label')
          .attr('x', (d) => d.x)
          .attr('y', (d) => d.y - 14)
          .text((d) => regionNames[d.id] || d.id)
      }

      // 窗口大小改变时重新初始化
      window.addEventListener('resize', function () {
        initializeProjection()
        mapGroup.selectAll('*').remove()
        linkGroup.selectAll('*').remove()
        nodeGroup.selectAll('*').remove()
        labelGroup.selectAll('*').remove()
        drawWorldMap()
        if (dataLoaded) {
          drawAllRoutes()
        }
      })

      initialize()
    </script>
  </body>
</html>
