<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Energy Flow Sankey Diagram</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: transparent;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      .container {
        width: 100%;
        height: auto;
        background: transparent;
        position: relative;
        overflow: hidden;
        padding: 0;
      }

      h1 {
        position: static;
        color: #333;
        margin: 0 0 10px 0;
        font-size: 18px;
        font-weight: 600;
        text-align: left;
      }

      .chart-container {
        width: 100%;
        height: auto;
        padding-top: 20px;
        overflow: visible;
        display: flex;
        justify-content: flex-start;
        align-items: flex-start;
      }

      .info-panel {
        margin-top: 20px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 5px;
        border-left: 4px solid #007bff;
      }

      .info-panel h3 {
        margin-top: 0;
        color: #007bff;
      }

      svg {
        max-width: 100%;
        height: auto;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="chart-container" id="chart-container"></div>
    </div>

    <script>
      // Animated Sankey Chart Function
      function AnimatedSankeyChart(
        {
          nodes, // an iterable of node objects (typically [{id}, …]); implied by links if missing
          links, // an iterable of link objects (typically [{source, target}, …])
        },
        {
          format = ',', // a function or format specifier for values in titles
          align = 'justify', // convenience shorthand for nodeAlign
          nodeId = (d) => d.id, // given d in nodes, returns a unique identifier (string)
          nodeGroup, // given d in nodes, returns an (ordinal) value for color
          nodeGroups, // an array of ordinal values representing the node groups
          nodeLabel, // given d in (computed) nodes, text to label the associated rect
          nodeTitle = (d) => `${d.id}\n${format(d.value)}`, // given d in (computed) nodes, hover text
          nodeAlign = align, // Sankey node alignment strategy: left, right, justify, center
          nodeSort, // comparator function to order nodes
          nodeWidth = 15, // width of node rects
          nodePadding = 10, // vertical separation between adjacent nodes
          nodeLabelPadding = 6, // horizontal separation between node and label
          nodeStroke = 'currentColor', // stroke around node rects
          nodeStrokeWidth, // width of stroke around node rects, in pixels
          nodeStrokeOpacity, // opacity of stroke around node rects
          nodeStrokeLinejoin, // line join for stroke around node rects
          linkSource = ({ source }) => source, // given d in links, returns a node identifier string
          linkTarget = ({ target }) => target, // given d in links, returns a node identifier string
          linkValue = ({ value }) => value, // given d in links, returns the quantitative value
          linkPath = d3.sankeyLinkHorizontal(), // given d in (computed) links, returns the SVG path
          linkTitle = (d) => `${d.source.id} → ${d.target.id}\n${format(d.value)}`, // given d in (computed) links
          linkColor = 'source-target', // source, target, source-target, or static color
          linkStrokeOpacity = 1, // link stroke opacity
          linkMixBlendMode = 'normal', // link blending mode
          colors = d3.schemeTableau10, // array of colors
          width = 1200, // outer width, in pixels
          height = 700, // outer height, in pixels
          marginTop = 5, // top margin, in pixels
          marginRight = 1, // right margin, in pixels
          marginBottom = 5, // bottom margin, in pixels
          marginLeft = 1, // left margin, in pixels
        } = {},
      ) {
        // Convert nodeAlign from a name to a function (since d3-sankey is not part of core d3).
        if (typeof nodeAlign !== 'function')
          nodeAlign =
            {
              left: d3.sankeyLeft,
              right: d3.sankeyRight,
              center: d3.sankeyCenter,
            }[nodeAlign] ?? d3.sankeyJustify

        // Compute values.
        const LS = d3.map(links, linkSource).map(intern)
        const LT = d3.map(links, linkTarget).map(intern)
        const LV = d3.map(links, linkValue)
        if (nodes === undefined) nodes = Array.from(d3.union(LS, LT), (id) => ({ id }))
        const N = d3.map(nodes, nodeId).map(intern)
        const G = nodeGroup == null ? null : d3.map(nodes, nodeGroup).map(intern)

        // Replace the input nodes and links with mutable objects for the simulation.
        nodes = d3.map(nodes, (_, i) => ({ id: N[i] }))
        links = d3.map(links, (_, i) => ({ source: LS[i], target: LT[i], value: LV[i] }))

        // Force linkColor to use source coloring for better visibility
        linkColor = 'source'

        // Compute default domains.
        if (G && nodeGroups === undefined) nodeGroups = G

        // Construct the scales with custom color palette
        const customColors = [
          '#E8B4B8',
          '#D4A5A5',
          '#BEA4B4',
          '#A5B8D4',
          '#A5D4B8',
          '#99C9DD',
          '#8CA361',
          '#A5A5D4',
          '#A5D4A5',
          '#F3AB98',
          '#EEE8A9',
          '#E8C5A0',
          '#C5A0E8',
          '#A0E8C5',
          '#E8A0C5',
          '#C5E8A0',
          '#A0C5E8',
          '#E8E8A0',
          '#A0E8E8',
          '#E8A0E8',
        ]
        const color =
          nodeGroup == null
            ? d3.scaleOrdinal(customColors)
            : d3.scaleOrdinal(nodeGroups, customColors)

        // Compute the Sankey layout.
        d3
          .sankey()
          .nodeId(({ index: i }) => N[i])
          .nodeAlign(nodeAlign)
          .nodeWidth(nodeWidth)
          .nodePadding(nodePadding)
          .nodeSort(nodeSort)
          .extent([
            [marginLeft, marginTop],
            [width - marginRight, height - marginBottom],
          ])({ nodes, links })

        // Compute titles and labels using layout nodes, so as to access aggregate values.
        if (typeof format !== 'function') format = d3.format(format)
        const Tl = nodeLabel === undefined ? N : nodeLabel == null ? null : d3.map(nodes, nodeLabel)
        const Tt = nodeTitle == null ? null : d3.map(nodes, nodeTitle)
        const Lt = linkTitle == null ? null : d3.map(links, linkTitle)

        // A unique identifier for clip paths (to avoid conflicts).
        const uid = `O-${Math.random().toString(16).slice(2)}`

        const svg = d3
          .create('svg')
          .attr('width', width)
          .attr('height', height)
          .attr('viewBox', [0, 0, width, height])
          .attr('style', 'max-width: 100%; height: auto; height: intrinsic;')

        const node = svg
          .append('g')
          .attr('stroke', nodeStroke)
          .attr('stroke-width', nodeStrokeWidth)
          .attr('stroke-opacity', nodeStrokeOpacity)
          .attr('stroke-linejoin', nodeStrokeLinejoin)
          .selectAll('rect')
          .data(nodes)
          .join('rect')
          .attr('x', (d) => d.x0)
          .attr('y', (d) => d.y0)
          .attr('height', (d) => d.y1 - d.y0)
          .attr('width', (d) => d.x1 - d.x0)

        // Apply colors to nodes - use node name as color key
        node.attr('fill', (d) => color(d.id))
        if (Tt) node.append('title').text(({ index: i }) => Tt[i])

        const link = svg.append('g').attr('fill', 'none').selectAll('g').data(links).join('g')

        // Remove gradient logic since we're using simple source coloring

        link
          .append('path')
          .attr('d', linkPath)
          .attr('stroke', (d) => color(d.source.id))
          .attr('stroke-opacity', 0.6)
          .attr('stroke-width', ({ width }) => Math.max(1, width))
          .call(Lt ? (path) => path.append('title').text(({ index: i }) => Lt[i]) : () => {})

        if (Tl)
          svg
            .append('g')
            .attr('font-family', 'sans-serif')
            .attr('font-size', 10)
            .selectAll('text')
            .data(nodes)
            .join('text')
            .attr('x', (d) =>
              d.x0 < width / 2 ? d.x1 + nodeLabelPadding : d.x0 - nodeLabelPadding,
            )
            .attr('y', (d) => (d.y1 + d.y0) / 2)
            .attr('dy', '0.35em')
            .attr('text-anchor', (d) => (d.x0 < width / 2 ? 'start' : 'end'))
            .text(({ index: i }) => Tl[i])

        function intern(value) {
          return value !== null && typeof value === 'object' ? value.valueOf() : value
        }

        return Object.assign(svg.node(), { scales: { color } })
      }

      // Function to parse CSV data
      function parseCSV(csvText) {
        const lines = csvText.split('\n')
        const links = []
        const nodeSet = new Set()

        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim()
          if (!line) continue

          const [source, target, value] = line.split(',').map((item) => item.trim())
          if (source && target && value) {
            const numValue = parseFloat(value)
            if (!isNaN(numValue)) {
              links.push({
                source: source,
                target: target,
                value: numValue,
              })
              nodeSet.add(source)
              nodeSet.add(target)
            }
          }
        }

        const nodes = Array.from(nodeSet).map((name) => ({ id: name }))
        return { nodes, links }
      }

      // 中文标签映射
      const labelMap = {
        "Agricultural 'waste'": "农业废物", "Biofuel imports": "生物燃料进口", "Biomass imports": "生物质进口",
        "Coal imports": "煤炭进口", "Coal reserves": "煤炭储备", "Coal": "煤炭",
        "Gas imports": "天然气进口", "Gas reserves": "天然气储备", "Gas": "天然气", "Ngas": "天然气",
        "Oil imports": "石油进口", "Oil reserves": "石油储备", "Oil": "石油",
        "Petroleum products": "石油产品", "UK land based bioenergy": "英国陆基生物能源",
        "Marine algae": "海洋藻类", "Solar PV": "太阳能光伏", "Solar Thermal": "太阳能热",
        "Solar": "太阳能", "Tidal": "潮汐能", "Wave": "波浪能", "Wind": "风能",
        "Geothermal": "地热能", "Hydro": "水电", "Nuclear": "核能",
        "Bio-conversion": "生物转化", "Thermal generation": "热力发电", "CHP": "热电联产",
        "District heating": "区域供热", "Electricity grid": "电网", "H2 conversion": "氢转化", "H2": "氢气",
        "Liquid": "液体燃料", "Solid": "固体燃料", "Losses": "损耗",
        "Over generation / exports": "过量发电/出口",
        "Heating and cooling - commercial": "商业供暖制冷",
        "Heating and cooling - homes": "家庭供暖制冷",
        "Industry": "工业", "Road transport": "道路交通", "Rail transport": "铁路交通",
        "Agriculture": "农业",
        "Lighting & appliances - commercial": "商业照明电器",
        "Lighting & appliances - homes": "家庭照明电器",
        "Domestic aviation": "国内航空", "International aviation": "国际航空",
        "International shipping": "国际航运", "Domestic navigation": "国内航运", "National navigation": "国内航运",
        "Non-energy use": "非能源使用",
        "Other waste": "其他废物", "Pumped heat": "热泵"
      };

      // Function to categorize nodes by their position in energy flow
      function categorizeNodes(nodes, links) {
        console.log(
          'All nodes:',
          nodes.map((n) => n.id),
        )

        const categories = {
          sources: [], // Primary energy sources
          intermediate1: [], // First level processing
          intermediate2: [], // Second level processing
          intermediate3: [], // Third level processing
          intermediate4: [], // Fourth level processing
          terminals: [], // Final consumers
        }

        // Define all node categories explicitly based on the CSV data
        const nodeCategories = {
          sources: [
            "Agricultural 'waste'",
            'Biofuel imports',
            'Biomass imports',
            'Coal imports',
            'Coal reserves',
            'Gas imports',
            'Gas reserves',
            'Geothermal',
            'Hydro',
            'Marine algae',
            'Nuclear',
            'Oil imports',
            'Oil reserves',
            'Other waste',
            'Pumped heat',
            'Solar',
            'Tidal',
            'UK land based bioenergy',
            'Wave',
            'Wind',
          ],
          intermediate1: ['Bio-conversion', 'Coal', 'Ngas', 'Oil', 'Solar PV', 'Solar Thermal'],
          intermediate2: ['Gas', 'Liquid', 'Solid'],
          intermediate3: ['Thermal generation'],
          intermediate4: ['District heating', 'Electricity grid', 'H2', 'H2 conversion'],
          terminals: [
            'Agriculture',
            'Domestic aviation',
            'Heating and cooling - commercial',
            'Heating and cooling - homes',
            'Industry',
            'International aviation',
            'International shipping',
            'Lighting & appliances - commercial',
            'Lighting & appliances - homes',
            'Losses',
            'National navigation',
            'Over generation / exports',
            'Rail transport',
            'Road transport',
          ],
        }

        // Categorize each node
        nodes.forEach((node) => {
          let categorized = false

          for (const [category, nodeList] of Object.entries(nodeCategories)) {
            if (nodeList.includes(node.id)) {
              categories[category].push(node)
              categorized = true
              break
            }
          }

          if (!categorized) {
            console.warn('Uncategorized node:', node.id)
            // Default to terminals for safety
            categories.terminals.push(node)
          }
        })

        console.log('Categorized nodes:', {
          sources: categories.sources.map((n) => n.id),
          intermediate1: categories.intermediate1.map((n) => n.id),
          intermediate2: categories.intermediate2.map((n) => n.id),
          intermediate3: categories.intermediate3.map((n) => n.id),
          intermediate4: categories.intermediate4.map((n) => n.id),
          terminals: categories.terminals.map((n) => n.id),
        })

        return categories
      }

      // Function to get links for specific stage - simplified logic
      function getLinksForStage(allLinks, fromNodes, toNodes) {
        const fromIds = new Set(fromNodes.map((n) => n.id))
        const toIds = new Set(toNodes.map((n) => n.id))

        // Simplified condition: show link if either source OR target is in current stage
        const stageLinks = allLinks.filter(
          (link) => fromIds.has(link.source) || toIds.has(link.target),
        )

        console.log(
          `Getting links where source in [${fromNodes.map((n) => n.id).join(', ')}] OR target in [${toNodes.map((n) => n.id).join(', ')}]: found ${stageLinks.length} links`,
        )

        return stageLinks
      }

      // Animated rendering function
      async function animateChart(chartData, container) {
        const categories = categorizeNodes(chartData.nodes, chartData.links)

        // Create the base chart structure
        const chart = AnimatedSankeyChart(chartData, {
          nodeLabel: (d) => labelMap[d.id] || d.id,
          nodeAlign: 'justify',
          linkColor: 'source',
          format: ',.0f',
          width: 1200,
          height: window.innerHeight - 120,
        })

        container.appendChild(chart)

        const svg = d3.select(chart)
        const allNodes = svg.selectAll('rect')
        const allLinks = svg.selectAll('path')
        const allLabels = svg.selectAll('text')

        console.log('Total elements found:', {
          nodes: allNodes.size(),
          links: allLinks.size(),
          labels: allLabels.size(),
        })

        // Hide everything initially
        allNodes.style('opacity', 0)
        allLinks.style('opacity', 0)
        allLabels.style('opacity', 0)

        const animationStages = [
          {
            name: 'sources',
            nodes: categories.sources,
            links: getLinksForStage(chartData.links, [], categories.sources),
          },
          {
            name: 'intermediate1',
            nodes: categories.intermediate1,
            links: getLinksForStage(chartData.links, [], categories.intermediate1),
          },
          {
            name: 'intermediate2',
            nodes: categories.intermediate2,
            links: getLinksForStage(chartData.links, [], categories.intermediate2),
          },
          {
            name: 'intermediate3',
            nodes: categories.intermediate3,
            links: getLinksForStage(chartData.links, [], categories.intermediate3),
          },
          {
            name: 'intermediate4',
            nodes: categories.intermediate4,
            links: getLinksForStage(chartData.links, [], categories.intermediate4),
          },
          {
            name: 'terminals',
            nodes: categories.terminals,
            links: getLinksForStage(chartData.links, [], categories.terminals),
          },
        ]

        console.log(
          'Animation stages:',
          animationStages.map((s) => ({
            name: s.name,
            nodeCount: s.nodes.length,
            linkCount: s.links.length,
            nodes: s.nodes.map((n) => n.id),
          })),
        )

        // Animation sequence
        for (let i = 0; i < animationStages.length; i++) {
          const stage = animationStages[i]
          console.log(`Starting stage ${i}: ${stage.name} with ${stage.nodes.length} nodes`)

          // Show nodes for this stage
          if (stage.nodes.length > 0) {
            const nodeIds = new Set(stage.nodes.map((n) => n.id))
            const selectedNodes = allNodes.filter((d) => nodeIds.has(d.id))
            console.log(`Selected ${selectedNodes.size()} nodes for stage ${stage.name}`)

            selectedNodes.transition().duration(1000).style('opacity', 1)

            // Show labels for these nodes
            const selectedLabels = allLabels.filter((d) => nodeIds.has(d.id))
            console.log(`Selected ${selectedLabels.size()} labels for stage ${stage.name}`)

            selectedLabels.transition().duration(1000).style('opacity', 1)
          }

          // Wait for nodes to appear
          await new Promise((resolve) => setTimeout(resolve, 1200))

          // Show links for this stage
          if (stage.links.length > 0) {
            console.log(`Showing ${stage.links.length} links for stage ${stage.name}`)

            stage.links.forEach((link) => {
              const selectedLinks = allLinks.filter(
                (d) => d.source.id === link.source && d.target.id === link.target,
              )
              console.log(
                `Found ${selectedLinks.size()} links for ${link.source} -> ${link.target}`,
              )

              selectedLinks.transition().duration(1500).style('opacity', 0.6)
            })

            // Wait for links to appear
            await new Promise((resolve) => setTimeout(resolve, 1800))
          }

          // Wait 1 second before next stage
          await new Promise((resolve) => setTimeout(resolve, 1000))
        }

        console.log('Animation complete')
      }

      // Residential highlighting animation
      function startResidentialAnimation(chart) {
        const svg = d3.select(chart)
        const allLinks = svg.selectAll('path')
        const allNodes = svg.selectAll('rect')

        // Store original colors
        const originalLinkColors = new Map()
        const originalNodeColors = new Map()

        allLinks.each(function (d) {
          originalLinkColors.set(this, d3.select(this).style('stroke'))
        })

        allNodes.each(function (d) {
          originalNodeColors.set(this, d3.select(this).style('fill'))
        })

        // Phase 1: Fade all paths to light gray
        console.log('Phase 1: Fading all paths to gray...')
        allLinks.transition().duration(1000).style('stroke', '#d3d3d3').style('opacity', 0.3)

        allNodes.transition().duration(1000).style('fill', '#e0e0e0').style('opacity', 0.5)

        // Phase 2: Restore residential-related paths after 2 seconds
        setTimeout(() => {
          console.log('Phase 2: Restoring residential-related paths...')

          // Find all residential-related nodes
          // Residential is likely "Heating and cooling - homes" and "Lighting & appliances - homes"
          const residentialNodes = ['Heating and cooling - homes', 'Lighting & appliances - homes']

          // Restore residential nodes
          allNodes
            .filter((d) => residentialNodes.includes(d.id))
            .transition()
            .duration(1500)
            .style('fill', function (d) {
              return originalNodeColors.get(this)
            })
            .style('opacity', 1)

          // Find all nodes that supply to residential
          const residentialInputLinks = allLinks
            .data()
            .filter((d) => residentialNodes.includes(d.target.id))
          const supplierNodes = new Set(residentialInputLinks.map((l) => l.source.id))

          // Restore supplier nodes
          allNodes
            .filter((d) => supplierNodes.has(d.id))
            .transition()
            .duration(1500)
            .style('fill', function (d) {
              return originalNodeColors.get(this)
            })
            .style('opacity', 1)

          // Restore links to residential
          allLinks
            .filter((d) => residentialNodes.includes(d.target.id))
            .transition()
            .duration(1500)
            .style('stroke', function (d) {
              return originalLinkColors.get(this)
            })
            .style('opacity', 1)
            .style('stroke-opacity', 1)

          // Also restore upstream paths that flow to residential
          allLinks
            .filter((d) => {
              return isResidentialRelated(d, allLinks.data())
            })
            .transition()
            .duration(1500)
            .style('stroke', function (d) {
              return originalLinkColors.get(this)
            })
            .style('opacity', 1)
            .style('stroke-opacity', 1)
        }, 2000)
      }

      // Helper function to check if a link is residential-related
      function isResidentialRelated(link, allLinks) {
        const residentialNodes = ['Heating and cooling - homes', 'Lighting & appliances - homes']

        // Direct residential connection
        if (residentialNodes.includes(link.target.id)) {
          return true
        }

        // Check if target node supplies to residential
        function suppliesToResidential(nodeId, visited = new Set()) {
          if (visited.has(nodeId)) return false
          visited.add(nodeId)

          const outputLinks = allLinks.filter((l) => l.source.id === nodeId)
          return outputLinks.some(
            (l) =>
              residentialNodes.includes(l.target.id) || suppliesToResidential(l.target.id, visited),
          )
        }

        return suppliesToResidential(link.target.id)
      }

      // Load CSV data and create static chart
      async function loadDataAndCreateChart() {
        try {
          const response = await fetch('../Sankey_Diagram/energy.csv')
          const csvText = await response.text()
          const energyData = parseCSV(csvText)

          // Create and render the chart statically
          const chart = AnimatedSankeyChart(energyData, {
            nodeLabel: (d) => labelMap[d.id] || d.id,
            nodeAlign: 'justify',
            linkColor: 'source',
            format: ',.0f',
            width: 1200,
            height: 650,
          })

          // Add the chart to the container
          document.getElementById('chart-container').appendChild(chart)

          // Start with colorful state, then loop animation
          setTimeout(() => {
            function loopHighlightingAnimation() {
              startResidentialAnimation(chart)
              setTimeout(loopHighlightingAnimation, 6000) // Loop every 6 seconds
            }
            loopHighlightingAnimation()
          }, 2000) // Start after 2 seconds to show initial colorful state
        } catch (error) {
          console.error('Failed to load CSV file:', error)
          document.getElementById('chart-container').innerHTML =
            '<p style="text-align: center; color: #e74c3c; padding: 50px;">Unable to load data file. Please ensure energy.csv is in the same directory.</p>'
        }
      }

      // Expose function for parent window to call
      window.playHighlightAnimation = function () {
        const chart = document.querySelector('#chart-container svg')
        if (chart) {
          startResidentialAnimation(chart)
        }
      }

      // Initialize when page loads
      document.addEventListener('DOMContentLoaded', loadDataAndCreateChart)
    </script>
  </body>
</html>
